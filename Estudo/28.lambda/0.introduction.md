<h1 align="center">Lambda</h1>

Antes de sabermos o que √© lambda, precisamos recapitular algumas coisas.

Imagina que voce quer criar um method para printar uma mensagem no terminal. Tradicionalmente, o passo a passo que voce seguiria seria:

1. Criar√≠amos uma interface para dizer como deve ser o method.
2. Criar√≠amos uma Class para implementar essa interface. Interface implementada, chamar√≠amos o method do contrato e setar√≠amos o body desse method.
3. Instanciar√≠amos essa Class para poder usar o method.

Seria assim:


```java
//INTERFACE
@FunctionalInterface //essa interface √© uma "functional interface". Ou seja, uma interface que possui apenas 1 abstract method sem corpo.
public interface MethodLegal {
    
    //apenas 1 abstract method
    public void printarMensagem();
}





// Class que vai receber a interface
public class ClasseBolada implements MethodLegal{

    //Sempre que implementamos uma interface, precisamos trazer pra c√° os methods do contrato e dizer qual √© o corpo desses methods.
    @Override
    public void printarMensagem() {
        System.out.println("Salve!");
    }  
}




//Main Class
public class Main{
    
    public static void main(String[] args){
        
        //instanciamos essa classe "Classe Bolada" para usar o method que queremos
        ClasseBolada c1 = new ClasseBolada();
        c1.printarMensagem(); //DALE. Usamos o method
    }
}
```


Em resumo...

- N√≥s declaramos o method
- Especificamos o corpo desse method
- Chamamos o method


<br>

√â a√≠ que entra o `Lambda`.


<hr>
<br>

## Lambda expressions

Uma lambda expression, nada mais √© do que voce declarar o corpo de um method de uma interface, sem precisar criar uma Class para isso. Em outras palavras, √© voce implementar uma interface sem precisar criar uma Class para isso.

Para trabalharmos com lambda, sempre vamos seguir essa linha:

1. Criar uma **functional interface**, contendo APENAS **1 abstract method**
2. Instanciar essa interface e declarar o corpo desse method.
3. Chamamos o method


Vamos seguir a syntax:

```java
(parameter, parameter2) -> expression;
(parameter1, parameter2) -> { varias expressions/code block };
```

<br>

## Lambda simples, sem parameters:


‚úèÔ∏è Seguindo o mesmo exemplo acima, crie uma functional interface para printar uma mensagem no terminal. Use lambda expression.

```java
//Interface
@FunctionalInterface //essa interface possui APENAS 1 abstract method
public interface MethodLegal {
    
    //apenas 1 abstract method
    public abstract void printarMensagem();
}





//Declaramos o corpo do method, sem ter precisado criar uma Class
public class Main{
    
    public static void main(String[] args){

        MethodLegal ml = () -> System.out.println("Salve!"); //Instanciou a interface e declarou o corpo do unico method que ela possui.
    }
}
```


<br>

Se voce parar para pensar...

```java
//isso:
public class ClasseBolada implements MethodLegal{ //criamos uma Class para definir o corpo do method

    @Override
    public void printarMensagem() {
        System.out.println("Salve!");
    }
    
}




//√© a mesma coisa que isso
MethodLegal ml = () -> {System.out.println("Salve!");}; //definimos o corpo do method na hora
```


<br>
<br>

## Lambda, passando varios parameters

‚úèÔ∏è Crie um abstract method, na functional interface, que retorne uma String e precise passar 2 parameters

```java
@FunctionalInterface //essa interface possui APENAS 1 abstract method
public interface MethodLegal {
    
    //apenas 1 abstract method
    public abstract String informacoesPessoais(String name, Integer age);
}



public class Main{
    public static void main(String[] args){

        InterfaceBolada ib = (nome, idade) -> {
            return String.format("Voce √© o(a) %s e tem %d anos de idade", nome, idade);
        }; 

        System.out.println(ib.mensagemPadrao("Roberta", 97));
    }
}
```

Bem simples. Basicamente, estamos criando um abstract method sem corpo, na functional interface, e declarando o corpo desse method na hora.

<hr>
<br>


## Praticando

### Exemplo 1:
‚úèÔ∏è Crie um abstract method, na functional interface, para printar todas as posicoes de uma Array de String.

```java
//functional interface

@FunctionalInterface //essa interface vai possui apenas 1 abstract method
public interface PercorrerLista {
    

    //apenas 1 abstract method
    public void printarLista(String... listaBolada); //Vamos passar uma array de String. Varargs √© daora!
}



//Class que vai setar o corpo do method
public class Main{
    public static void main(String[] args){

        //definimos o corpo do method

        PercorrerLista pl = (variosItens) -> {
            for(String i : variosItens){
                System.out.println(i);
            }
        };

        //chamamos o method
        pl.printarLista("salve","roberta","diego","zica");

    }
}
```

<br>
<br>

## Trabalhando com lambda + generics

Relembrando um pouquinho sobre **generics**:
- Se a Class vai possuir attributes generics, informamos `<T>` l√° em cima na Class. 
- Se o method vai possuir parameters generics, informamos  `<T>` no proprio method, antes do retorno.

- Quando estamos trabalhando com uma interface que possui m√©todos com par√¢metros gen√©ricos, precisamos informar `<T>` no escopo da interface, na declara√ß√£o da interface.

<br>

Crie um method para printar todas as posicoes de uma lista. Essa lista, pode ser de qualquer Class/tipo.

<br>

### Fazendo da maneira tradicional, sem usar lambda


```java
public class ClassBolada{ //criamos uma abstract class padraozinha. Como nao podemos instanciar objetos de uma abstract Class, entao vamos criar um method static memso.

    public static <T> void printarLista(List<T> listaBolada){ //Podemos passar como argumento uma lista de qualquer Classe. Como estamos usando generics em um method, precisamos informar <T> antes do retorno desse method
        for(T i : listaBolada){
            System.out.println(i.toString());
        }
    }
}

//lendo, ficaria assim:
//Criamos um method sem retorno, onde o parametro √© uma lista<Generica>. S√≥ precisamos especificar o tipo dessa lista, quando chamarmos o method.



//chamando o method
public class Main{
    
    public static void main(String[] args){

        //criando algumas listas
        List<String> names = List.of("Gilberto", "camila", "Amanda", "Joao");
        
        List<Integer> numbers = List.of(44,99,20,64,80,13);
        
        List<Person> persons = List.of(
            new Person("David", 29),
            new Person("Clara", 31));


        //chamando o method para printar
        System.out.println("\nNames:");
        ClassBolada.printarLista(names); //o java automaticamente identifica a Class dessa lista. Por isso, nao precisamos informar <String>. Sacou?? Como estamos passando uma lista de "String", ele automaticamente identifica.

        System.out.println("\nNumbers:");
        ClassBolada.printarLista(numbers);

        System.out.println("\nPersons:");
        ClassBolada.printarLista(persons);

    }   
}

```

<br>
<br>

### Utilizando lambda

Aqui que fica interessante. Vamos usar **lambda** + **generics**.

‚ö†Ô∏è SEMPRE que estamos trabalhando com interfaces com methods contendo parametros genericos, precisamos definir esse parametro generico no level da Class.


```java
//FunctionalInterface

@FunctionalInterface //essa interface pode possuir apenas 1 abstract method
public interface PercorrerListas <T>{
    
    //apenas 1 abstract method
    public void printarLista(List<T> listaBolada); //podemos passar como argumento uma lista de "qualquer Class"
}



//Declarando o corpo do method
public class Main{
    
    public static void main(String[] args){

        //criando algumas listas
        List<String> animals = List.of("Lion", "Tiger", "Eagle");

        List<Integer> numbers = List.of(1,5,9,8,55,6,1);

        List<Person> personas = List.of(
            new Person("Amanda", 33),
            new Person("Luan", 31),
            new Person("Josefa", 94)
        );


        //declaramos o corpo do method, utlizando lambda
        PercorrerListas<String> pl1 = (listaBolada) ->{
            for(String i : listaBolada){
                System.out.println(i);
            }
        };

        PercorrerListas<Integer> pl2 = (listaBolada) ->{
            for(Integer i : listaBolada){
                System.out.println(i);
            }
        };

        PercorrerListas<Person> pl3 = (listaBolada) ->{
            for(Person i : listaBolada){
                System.out.println(i);
            }
        };


        //chamamos o method
        pl1.printarLista(animals);
        pl2.printarLista(numbers);
        pl3.printarLista(personas);
    }
}
```


üìñ Relembrando:

Relembrando um pouquinho sobre **generics**:
- Se a Class vai possuir attributes generics, informamos `<T>` l√° em cima na Class. 
- Se o method vai possuir parameters generics, informamos  `<T>` no proprio method, antes do retorno.

- Quando estamos trabalhando com uma interface que possui m√©todos com par√¢metros gen√©ricos, precisamos informar `<T>` no escopo da interface, na declara√ß√£o da interface.

<hr>
<br>

## Utilizando o forEach() em lambda


### for normal
```java
System.out.println("\n============= for normal =================\n");
for(int i = 0; i<numbers.size(); i++){
    System.out.println(numbers.get(i));
}
System.out.println("\n=========================================\n");
```

<br>

### for each normal

```java
System.out.println("\n============= for each =================\n");
for(Integer i : numbers){
    System.out.println(i);
}
```

<br>

### for each com lambda

```java
System.out.println("\n============= lambda way =================\n");
numbers.forEach(i -> System.out.println(i)); //como s√≥ tem 1 parametro, nao precisamos colocar (i) -> {]
//numbers.forEach((i) -> {System.out.println(i);}); // mesma coisa
System.out.println("\n=========================================\n");
```

<br>
<br>

## Relembrando <img src="https://cdn-icons-png.flaticon.com/512/201/201652.png" alt="imagem" width="50px" align="center">
Em termos simples, uma express√£o lambda permite que voc√™ implemente uma functional interface (uma interface que cont√©m apenas 1 abstract method) sem a necessidade de criar uma classe para isso. 


Lembrando que uma expressao lambda SEMPRE est√° associada a uma **functional interface**. Ou seja, uma interface com apenas 1 abstract method. Sempre que voc√™ ver uma lambda expression, saiba que voce est√° definindo o corpo de um abstract method, de uma functional interface.